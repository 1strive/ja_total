<!--
 * @Author: JA
 * @Date: 2022-08-31 00:13:22
 * @LastEditTime: 2022-08-31 18:22:33
 * @LastEditors: JA
-->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>diff</title>
</head>

<body>
    <div id="root">

    </div>
    <script>
        class VNode {
            constructor(tag, data, children) {
                this.tag = tag;
                this.data = data;
                this.children = children;
                this.elm = ''
                // text属性用于标志Vnode节点没有其他子节点，只有纯文本(为true时只有纯文本)
                this.text = util._isPrimitive(this.children) ? this.children : ''
            }
        }
        class Util {
            constructor() { }
            // 检测基础类型
            _isPrimitive(value) {
                return (typeof value === 'string' || typeof value === 'number' || typeof value === 'symbol' || typeof value === 'boolean')
            }
            // 判断值不为空
            _isDef(v) {
                return v !== undefined && v !== null
            }
        }
        // 工具类的使用
        const util = new Util();

        // 接下来需要创建另一个类模拟将render函数转换为Vnode,并将Vnode渲染为真实DOM的过程，
        // 我们将这个类定义为Vn,Vn具有两个基本的方法createVnode, createElement, 
        // 分别实现创建虚拟Vnode,和创建真实DOM的过程。
        // createVnode
        // 创建Vnode
        // diff.js
        (function diff(global) {
            class Vn {
                constructor() { }
                // 创建虚拟Vnode
                createVnode(tag, data, children) {
                    return new VNode(tag, data, children)
                }
                createElement(vnode, options) {
                    let el = options.el;
                    if (!el || !document.querySelector(el)) return console.error('无法找到根节点')
                    let _createElement = vnode => {
                        const { tag, data, children } = vnode;
                        const ele = document.createElement(tag);
                        // 添加属性
                        this.setAttr(ele, data);
                        // 简单的文本节点，只要创建文本节点即可
                        if (util._isPrimitive(children)) {
                            const testEle = document.createTextNode(children);
                            ele.appendChild(testEle)
                        } else {
                            // 复杂的子节点需要遍历子节点递归创建节点。
                            children.map(c => ele.appendChild(_createElement(c)))
                        }
                        return ele
                    }
                    document.querySelector(el).appendChild(_createElement(vnode))
                }
                setAttr(el, data) {
                    if (!el) return
                    const attrs = data.attrs;
                    if (!attrs) return;
                    Object.keys(attrs).forEach(a => {
                        el.setAttribute(a, attrs[a]);
                    })
                }


                diffVnode(nVnode, oVnode) {
                    if (!this._sameVnode(nVnode, oVnode)) {
                        // 直接更新根节点及所有子节点
                        // return ***
                    }
                    this.generateElm(oVnode);
                    this.patchVnode(nVnode, oVnode);
                }

                //只进行同层节点的比较，节点不一致，直接用新节点及其子节点替换旧节点
                _sameVnode(n, o) {
                    return n.tag === o.tag;
                }
                // generateElm的作用是跟踪每个节点实际的真实节点，方便在对比虚拟节点后实时更新真实DOM节点。
                // 虽然Vue源码中做法不同，但是这不是分析diff的重点。
                generateElm(vnode) {
                    const traverseTree = (v, parentEl) => {
                        let children = v.children;
                        if (Array.isArray(children)) {
                            children.forEach((c, i) => {
                                c.elm = parentEl.childNodes[i];
                                traverseTree(c, c.elm)
                            })
                        }
                    }
                    traverseTree(vnode, this.el);
                }
                // patchVnode是新旧Vnode对比的核心方法，对比的逻辑如下。
                // 节点相同，且节点除了拥有文本节点外没有其他子节点。这种情况下直接替换文本内容。
                // 新节点没有子节点，旧节点有子节点，则删除旧节点所有子节点。
                // 旧节点没有子节点，新节点有子节点，则用新的所有子节点去更新旧节点。
                // 新旧都存在子节点。则对比子节点内容做操作。
                patchVnode(nVnode, oVnode) {
                    if (nVnode.text && nVnode.text !== oVnode) {
                        // 当前真实dom元素
                        let ele = oVnode.elm
                        // 子节点为文本节点
                        ele.textContent = nVnode.text;
                    } else {
                        const oldCh = oVnode.children;
                        const newCh = nVnode.children;
                        // 新旧节点都存在。对比子节点
                        if (util._isDef(oldCh) && util._isDef(newCh)) {
                            this.updateChildren(ele, newCh, oldCh)
                        } else if (util._isDef(oldCh)) {
                            // 新节点没有子节点
                        } else {
                            // 老节点没有子节点
                        }
                    }
                }
                updateChildren(el, newCh, oldCh) {
                    // 新children开始标志
                    let newStartIndex = 0;
                    // 旧children开始标志
                    let oldStartIndex = 0;
                    // 新children结束标志
                    let newEndIndex = newCh.length - 1;
                    // 旧children结束标志
                    let oldEndIndex = oldCh.length - 1;
                    let oldKeyToId;
                    let idxInOld;
                    let newStartVnode = newCh[newStartIndex];
                    let oldStartVnode = oldCh[oldStartIndex];
                    let newEndVnode = newCh[newEndIndex];
                    let oldEndVnode = oldCh[oldEndIndex];
                    // 遍历结束条件
                    while (newStartIndex <= newEndIndex && oldStartIndex <= oldEndIndex) {
                        // 新children开始节点和旧开始节点相同
                        if (this._sameVnode(newStartVnode, oldStartVnode)) {
                            this.patchVnode(newCh[newStartIndex], oldCh[oldStartIndex]);
                            newStartVnode = newCh[++newStartIndex];
                            oldStartVnode = oldCh[++oldStartIndex]
                        } else if (this._sameVnode(newEndVnode, oldEndVnode)) {
                            // 新childre结束节点和旧结束节点相同
                            this.patchVnode(newCh[newEndIndex], oldCh[oldEndIndex])
                            oldEndVnode = oldCh[--oldEndIndex];
                            newEndVnode = newCh[--newEndIndex]
                        } else if (this._sameVnode(newEndVnode, oldStartVnode)) {
                            // 新childre结束节点和旧开始节点相同
                            this.patchVnode(newCh[newEndIndex], oldCh[oldStartIndex])
                            // 旧的oldStartVnode移动到尾部
                            el.insertBefore(oldCh[oldStartIndex].elm, null);
                            oldStartVnode = oldCh[++oldStartIndex];
                            newEndVnode = newCh[--newEndIndex];
                        } else if (this._sameVnode(newStartVnode, oldEndVnode)) {
                            // 新children开始节点和旧结束节点相同
                            this.patchVnode(newCh[newStartIndex], oldCh[oldEndIndex]);
                            el.insertBefore(oldCh[oldEndIndex].elm, oldCh[oldStartIndex].elm);
                            oldEndVnode = oldCh[--oldEndIndex];
                            newStartVnode = newCh[++newStartIndex];
                        } else {
                            // 都不符合的处理，查找新节点中与对比旧节点相同的vnode
                            this.findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
                        }
                    }
                    // 新节点比旧节点多，批量增加节点
                    if (oldEndIndex <= oldStartIndex) {
                        for (let i = newStartIndex; i <= newEndIndex; i++) {
                            // 批量增加节点
                            this.createElm(oldCh[oldEndIndex].elm, newCh[i])
                        }
                    }
                }

                createElm(el, vnode) {
                    let tag = vnode.tag;
                    const ele = document.createElement(tag);
                    this._setAttrs(ele, vnode.data);
                    const testEle = document.createTextNode(vnode.children);
                    ele.appendChild(testEle)
                    el.parentNode.insertBefore(ele, el.nextSibling)
                }


                // 前面有个分支，当四种比较节点都找不到匹配时，会调用findIdxInOld找到旧节点中和新的比较节点一致的节点。
                // 节点搜索在数量级较大时是缓慢的。查看Vue的源码，发现它在这一个环节做了优化，也就是我们经常在编写列表时被要求加入的唯一属性key，
                // 有了这个唯一的标志位，我们可以对旧节点建立简单的字典查询，只要有key值便可以方便的搜索到符合要求的旧节点。修改代码：

                //都不满足时寻找的过程通过设定key用map实现
                // 查找匹配值
                findIdxInOld(newStartVnode, oldCh, start, end) {
                    for (var i = start; i < end; i++) {
                        var c = oldCh[i];
                        if (util.isDef(c) && this.sameVnode(newStartVnode, c)) { return i } else {
                            // 都不符合的处理，查找新节点中与对比旧节点相同的vnode
                            if (!oldKeyToId) oldKeyToId = this.createKeyMap(oldCh, oldStartIndex, oldEndIndex);
                            idxInOld = util._isDef(newStartVnode.key) ? oldKeyToId[newStartVnode.key] : this.findIdxInOld(newStartVnode, oldCh, oldStartIndex, oldEndIndex);
                            // 后续操作
                        }

                        // 建立字典
                        createKeyMap(oldCh, start, old) {
                            const map = {};
                            for (let i = start; i < old; i++) {
                                if (oldCh.key) map[key] = i;
                            }
                            return map;
                        }

                    }
                }

            }
            vn = new Vn()
        })()
        let arr =
            [{
                tag: 'div',
                text: '焦傲',
            }, {
                tag: 'span',
                text: 3
            }, {
                tag: 'strong',
                text: 4
            }];
        let createVnode = function () {
            let _c = vn.createVnode;
            return _c('div', { attrs: { id: 'test' } }, arr.map(a => _c(a.tag, {}, a.text)))//简化版，只有一层子元素
        }
        vn.createElement(createVnode(), { el: '#root' })
        // // 元素内容结构

        /************************************/
        //DIFF过程
        // index.html
        setTimeout(function () {
            arr = [{ tag: 'span', text: 1 }, { tag: 'strong', text: 2 }, { tag: 'i', text: 3 }, { tag: 'i', text: 4 }]
            // newVnode 表示改变后新的Vnode树
            const newVnode = createVnode();
            // diffVnode会比较新旧Vnode树，并完成视图更新
            vn.diffVnode(newVnode, createVnode());
        })




    </script>
</body>

</html>