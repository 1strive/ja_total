<!--
 * @Author: JA
 * @Date: 2022-03-27 11:42:18
 * @LastEditTime: 2022-03-27 14:41:10
 * @LastEditors: JA
-->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        /*
 * @Author: JA
 * @Date: 2022-03-27 00:29:02
 * @LastEditTime: 2022-03-27 11:41:08
 * @LastEditors: JA
 */


        // 基于观察者模式，我们抽象出Subject和Object两个类，并解决了状态通知问题。还剩下两个问题：

        // 1.如何监听property变化？
        // 2.Observer对象如何订阅依赖的Subject对象？

        //  对于第一个问题，我们知道：当且仅当程序对一个变量进行“写”操作时，变量的值可能会改变。所以可通过拦截property的”写“操作或代理的方式来监听变化。
        //  第二个问题，只有当组件被渲染时才知道依赖了哪些property，此时对property进行”读“操作，并把Observer对象传给Subject对象
        // ，这样就可以通过拦截property的”读“操作或代理的方式来订阅Subject。
        //  实现方案有两种，Vue2用的是Object.defineProperty()来拦截读写操作，而Vue3是用ES6的Proxy代理方式。
        //  在创建Vue实例时，遍历构造函数的data选项的所有property，并用Object.defineProperty() 给 property设置set()和get()
        // ，这样property在被访问/修改时会触发get()和set()，即可以在get()中订阅Subject，在set()中通知变更。

        // 模板
        // function defineReactive(data, pro, val) {
        //     Object.defineProperty(data, pro, {
        //         enumerable: true,
        //         configurable: true,
        //         set(data) {
        //             // do someting when write(监听变化)
        //             val = data
        //         },
        //         get() {
        //             // do someting when read(订阅Subject)
        //             return val
        //         }
        //     })
        // }

        // 总结
        //  本文实现了一个简单的响应式系统，来帮助大家理解响应式原理。主要包括监听变化、订阅依赖和状态通知三个部分：

        // 状态通知：我们基于观察者模式，抽象出Subject类和Observer类，解决了状态通知的问题。

        // 监听变化：在创建Vue实例时，遍历构造函数的data选项的所有property，并用Object.defineProperty() 
        // 设置 property的set()和get()。当property被修改时，会触发set()中的Subject对象通知组件更新。

        // 订阅依赖：每个组件实例都对应一个Observer对象，它会在组件渲染时收集依赖的property，并通过“读”操作触发get()，
        // 完成订阅property对应的Subject对象。当Observer对象接收到变更通知时，会对组件进行更新。

        // 总结实现

        class Subject {
            //想要订阅的目标观察者
            static target
            observers = []
            // constructor(){
            // this.observers = [];
            // }
            subscribe() {
                console.log(this.observers, 'tar');
                let observer = Subject.target
                if (!this.observers.includes(observer)) {
                    this.observers.push(Subject.target)//不含时添加
                }
            }

            notify() {
                this.observers.forEach(observer => {
                    observer.update() //更新每个依赖组件
                })
            }
        }

        //正在评估的当前目标观察者。
        //这是全局唯一的，因为只有一个观察者
        //可以一次性评估。

        Subject.target = null
        const targetStack = []

        function pushTarget(target) {
            targetStack.push(target)
            Subject.target = target
        }

        function popTarget() {
            targetStack.pop()
            Subject.target = targetStack[targetStack.length - 1]
        }
        /**
        *观察者解析表达式
        *并在表达式值更改时触发回调。
        *这用于$watch（）api和指令。
         */
        class Observer {
            constructor(vm, exp, cb) {//cb即callback
                // console.log(exp, 'exp');//属性名
                this.vm = vm//data
                this.cb = cb
                // parse expression for getter
                this.getter = parsePath(exp)
                // console.log(this,'this');
                pushTarget(this)
                //读取属性触发订阅
                this.value = this.get() //返回属性值
                popTarget()
            }

            /**
         * get the property value
         */

            get() {
                const vm = this.vm
                return this.getter.call(vm, vm)//第二个参数是传参
            }

            /**
          * Observer interface. 观察者接口
          * Will be called when a subject changes.  subject对象改变时调用
          */
            update() {
                const oldValue = this.value
                this.value = this.get()
                // console.log(this.value, 'value');
                this.cb.call(this.vm, this.value, oldValue)//相当于this.vm.cb(this.value,oldValue)
            }


        }

        function parsePath(path) {
            const segments = path.split('.')
            // console.log(segments,'path');
            return function (obj) {
                // console.log(obj, 'obj');
                for (let i = 0; i < segments.length; i++) { //通过循环实现深层监视
                    if (!obj) return
                    obj = obj[segments[i]] //读取属性 调取订阅方法
                }
                return obj
            }
        }

        function defineReactive(data, pro, val) {
            let subject = new Subject()
            Object.defineProperty(data, pro, {
                enumerable: true,
                configurable: true, //控制属性是否可以被删除，默认值是false
                set(data) {
                    // do someting when write(监听变化)
                    console.log('改动');
                    if (data === val) { //若一致则不进行渲染 节省资源
                        return
                    }
                    val = data
                    subject.notify()
                },
                get() {
                    // do someting when read(订阅Subject)
                    // 在创建Observer实例时，会对property执行一次读操作，并把Observer实例通过全局变量传参。
                    console.log('读取');
                    subject.subscribe()
                    return val
                }
            })
        }

        let data = { pro1: '0' }
        defineReactive(data, 'pro1', '2')
        // console.log(data,'data');
        let observer = new Observer(data, 'pro1', (newVal, oldVal) => {
            console.log(`数据变化，刷新视图。newVal=${newVal},oldVal=${oldVal}`);
        })
        // console.log(Subject.target,'tas');
        data.pro1 = '666';


//输出
// > data.pro1='666';
// > 数据变化，刷新视图。newVal=666，oldVal=0
    </script>
</body>

</html>