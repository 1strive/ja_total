/*
 * @Author: JA
 * @Date: 2022-09-17 16:21:40
 * @LastEditTime: 2022-09-17 18:19:04
 * @LastEditors: JA
 */
// 在上述过程中，客户端在拿到服务器的公钥后，会生成一个随机码(用 KEY 表示，这个 KEY 就是后续双方用于对
// 称加密的密钥)，然后客户端使用公钥把 KEY 加密后再发送给服务器，服务器使用私钥将其解密，这样双方
// 就有了同一个密钥 KEY，然后双方再使用 KEY 进行对称加密交互数据。在非对称加密传输 KEY 的输过程中
//，即便第三方获取了公钥和加密后的 KEY，在没有私钥的情况下也无法破解 KEY(私钥存在服务器，泄露风
//  险极小)，也就保证了接下来对称加密的数据安全。而上面这个流程图正是 HTTPS 的雏形，HTTPS 正好
// 综合了这两种加密算法的优点，不仅保证了通信安全，还保证了数据传输效率。



// "client hello"消息： 客户端通过发送"client hello"消息向服务器发起握手请求，该消息包含了客户端所支持的 TLS 版本和密码组合以供服务器进行选择，还有一个"client random"随机字符串。
// "server hello"消息： 服务器发送"server hello"消息对客户端进行回应，该消息包含了数字证书，服务器选择的密码组合和"server random"随机字符串。
// 验证： 客户端对服务器发来的证书进行验证，确保对方的合法身份，验证过程可以细化为以下几个步骤：

// 检查数字签名
// 验证证书链 (这个概念下面会进行说明)
// 检查证书的有效期
// 检查证书的撤回状态 (撤回代表证书已失效)


// "premaster secret"字符串： 客户端向服务器发送另一个随机字符串"premaster secret (预主密钥)"，这个字符串是经过服务器的公钥加密过的，只有对应的私钥才能解密。
// 使用私钥： 服务器使用私钥解密"premaster secret"。
// 生成共享密钥： 客户端和服务器均使用 client random，server random 和 premaster secret，并通过相同的算法生成相同的共享密钥 KEY。
// 客户端就绪： 客户端发送经过共享密钥 KEY加密过的"finished"信号。
// 服务器就绪： 服务器发送经过共享密钥 KEY加密过的"finished"信号。
// 达成安全通信： 握手完成，双方使用对称加密进行安全通信。
