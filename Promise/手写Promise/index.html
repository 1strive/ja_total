<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>index</title>
</head>

<body>
    <script>
        // 可进行链式调用，且每次 then 返回了新的 Promise(2次打印结果不一致，如果是同一个实例，打印结果应该一致。
        // 只输出第一次 resolve 的内容，reject 的内容没有输出，即 Promise 是有状态且状态只可以由pending -> fulfilled或 pending-> rejected,是不可逆的。
        // then 中返回了新的 Promise,但是then中注册的回调仍然是属于上一个 Promise 的。
        function Promise(fn) {
            let state = 'pending';
            let value = null;
            const callbacks = [];

            this.then = function (onFulfilled) {
                console.log(onFulfilled, 'onFulfilled');
                return new Promise((resolve, reject) => {
                    handle({ //桥梁，将新 Promise 的 resolve 方法，放到前一个 promise 的回调对象中
                        onFulfilled,
                        resolve
                    })
                })
            }

            function handle(callback) {
                console.log(callback, 'callback');
                if (state === 'pending') {
                    callbacks.push(callback)
                    return;
                }

                if (state === 'fulfilled') {
                    if (!callback.onFulfilled) {
                        callback.resolve(value)
                        return;
                    }
                    const ret = callback.onFulfilled(value) //处理回调 //此处可返回Promise?
                    callback.resolve(ret) //处理下一个 promise 的resolve
                }
            }
            function resolve(newValue) {
                console.log(newValue, 'newValue');
                const fn = () => {
                    if (state !== 'pending') return

                    if (newValue && (typeof newValue == 'object' || typeof newValue === 'function')) {
                       const {then} = newValue
                       if(typeof then === 'function')  {
                           //newValue 为新产生的Promise，此时resolve为上个promise的resolve
                           //相当于调用了新产生Promise的then方法，注入了上个promise的resolve为其回调
                           then.call(newValue,resolve)
                           return
                       }            
                    }

                    state = 'fulfilled';
                    value = newValue//回调函数返回的结果会被当作 value 返回给下一个 Promise(也就是then 中产生的 Promise)
                    // 同时下一个 Promise的状态也会被改变(执行 resolve 或 reject)，然后再去执行其回调,以此类推下去...链式调用的效应就出来了。
                    handelCb()
                }
                setTimeout(fn, 0) //基于 PromiseA+ 规范
            }

            function handelCb() {
                console.log(callbacks, 'handelCb');
                while (callbacks.length) {
                    console.log(callbacks, '111');
                    const fulfilledFn = callbacks.shift();
                    handle(fulfilledFn);
                };
            }

            fn(resolve) //value被赋值
        }

        const p = new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve({ test: 1 })
            }, 1000)
        })

        p.then((data) => {
            console.log('result1', data)
            //dosomething
            console.log('result3')
        })
//result1 { test: 1 }
//result3

    </script>
</body>

</html>