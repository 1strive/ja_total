<!--
 * @Author: JA
 * @Date: 2022-11-07 18:51:41
 * @LastEditTime: 2022-11-17 16:40:17
 * @LastEditors: JA
-->
<!DOCTYPE html>
<html>

<head>
	<meta name="keywords" content="风舞红枫,前端技术,canvas" />
	<meta name="description" content="风舞红枫,前端技术,canvas,vue,react,node,个人博客" />
	<meta charset="utf-8">
	<link rel="icon" href="../image/icon2.ico">
	<title>同一条路径</title>
	<style type="text/css">
		html,
		body {
			height: 100%;
			margin: 0;
			padding: 0;
		}

		canvas {
			display: block;
			margin: 0 auto;
		}


		.btn {
			position: relative;
			left: 50%;
			top: 5%;
			transform: translateX(-50%);
		}
	</style>
</head>

<body>
	<button class="btn">执行</button>
	<canvas id="myCanvas" width="800" height="800"></canvas>
</body>
<script type="text/javascript">
	const btn = document.querySelector('.btn')
	btn.onclick = () => {
		handleExecute()
	}
	function handleExecute() {
		const canvas = document.querySelector("#myCanvas");
		const ctx = canvas.getContext('2d')

		//起点终点坐标
		const startX = 100
		const startY = 100
		const endX = 700
		const endY = 700
		let nextX
		let nextY

		//第一帧执行时间
		let startTime
		//期望动画持续时间
		const duration = 1000

		//创建路径
		ctx.beginPath()

		ctx.moveTo(startX, startY)

		// 设置线条样式
		ctx.strokeStyle = `rgba(${81}, ${160}, ${255},${0.25})`
		ctx.lineWidth = 4

		/*
		 * 动画帧绘制方法.
		 * currentTime是requestAnimation执行回调方法step时会传入的一个执行时的时间
		 * (由performance.now()获得).
		 * */

		const step = (currentTime) => {

			!startTime && (startTime = currentTime)

			const timeElapsed = currentTime - startTime

			const progress = Math.min(timeElapsed / duration, 1)

			//绘制方法
			const draw = () => {
				nextX = startX + (endX - startX) * progress
				nextY = startY + (endY - startY) * progress

				ctx.lineTo(nextX, nextY)

				ctx.stroke()

			}

			draw()

			if (progress < 1) {
				requestAnimationFrame(step)
			} else {
				console.log('执行完毕');
			}

		}
		requestAnimationFrame(step)

	}

</script>

</html>