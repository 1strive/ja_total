<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .kkk {
            background-color: black;
            width: 500px;
            height: 800px;
            padding-top: 200px;
        }
    </style>
</head>

<body>
    <button id="btn">123</button>
    <button id="btn1">321</button>
    <!-- <div class="kkk">
        <img src="https://liangcang-material.alicdn.com/prod/upload/773123b02c59477d90e22200abe7415f.webp" alt="">
    </div> -->
    <script>
        const setWindowProp = (prop, value, isDel) => {
            if (value === undefined || isDel) {
                delete window[prop]
            } else {
                window[prop] = value
            }
        }

        class legacySandbox {
            active() {
                //将沙箱内的更改恢复
                this.currentUpdatedPropsValueMap.forEach((v, p) => setWindowProp(p, v))
            }

            inactive() {
                // 将沙箱期间修改的属性还原为原先的属性
                this.modifiedPropsOriginalValueMapInSandbox.forEach((v, p) => setWindowProp(p, v))
                // 将沙箱期间新增的全局变量删除（撤销全局变量赋值）
                this.addedPropsMapInSandbox.forEach((_, p) =>
                    // (method) Map<any, any>.forEach(callbackfn: (value: any, key: any, map: Map<any, any>) => void, thisArg?: any): void
                    setWindowProp(p, undefined, true)
                );
                this.timer.forEach((i) => {
                    clearInterval(i)
                    clearTimeout(i)
                })
                this.events.forEach((i) => {
                    window.removeEventListener(i[0], i[1])
                })

                //移除事件监听器
                //清除定时器
            }

            constructor(name) {
                this.name = name
                this.proxy = null
                //存放新增的全局变量
                this.addedPropsMapInSandbox = new Map()
                // 存放沙箱期间更新的全局变量,记录原始值
                this.modifiedPropsOriginalValueMapInSandbox = new Map();
                // 存在新增和修改的全局变量，在沙箱激活的时候使用
                this.currentUpdatedPropsValueMap = new Map();
                //存放定时器
                this.timer = []
                //存放事件监听器
                this.events = []
                const {
                    addedPropsMapInSandbox,
                    currentUpdatedPropsValueMap,
                    modifiedPropsOriginalValueMapInSandbox,
                    timer,
                    events
                } = this

                const rawWindow = window
                const fakewindow = Object.create(null)
                const proxy = new Proxy(fakewindow, {
                    set(target, prop, value) {
                        // 如果 window 没有该属性，代表发生了新增，则将此属性记录到新增属性里
                        if (!window.hasOwnProperty(prop)) {
                            addedPropsMapInSandbox.set(prop, value);
                        } else if (!modifiedPropsOriginalValueMapInSandbox.has(prop)) {
                            // 如果window对象有该属性，但未发生过更新，则记录该
                            // 属性在 window 上的原始值，等沙箱卸载后还原全局环境
                            const originalValue = window[prop]
                            modifiedPropsOriginalValueMapInSandbox.set(prop, originalValue)
                        }

                        //*** 更新到currentUpdatedPropsValueMap和全局window上
                        // 不管是新增还是更新，都是当前沙箱环境的变化
                        // 记录修改属性以及修改后的值
                        currentUpdatedPropsValueMap.set(prop, value)
                        // 更新至全局 window 上，还是会对 window 产生一定的污染(只在一个页面中有多个微前端应用时有影响)
                        rawWindow[prop] = value;
                        // console.log(rawWindow === window);//true
                        return true;
                    },
                    //!!!!!!返回的是window上的值
                    get(target, prop) {
                        // 获取原始window对象的属性
                        const value = window[prop];
                        // 特殊处理构造函数，比如 BigInt64Array
                        function isConstructor(func) {
                            try {
                                new new Proxy(func, { construct: () => ({}) });
                                return true;
                            } catch (err) {
                                return false;
                            }
                        }
                        // 检查属性是否可能是一个构造函数
                        if (typeof value === 'function' && isConstructor(prop)) {
                            return new Proxy(value, {
                                // 对构造函数使用construct陷阱
                                construct: (target, argumentsList) => {
                                    return new target(...argumentsList);
                                },
                                // 对普通函数调用使用apply陷阱
                                apply: (target, thisArg, argumentsList) => {
                                    return target.apply(window, argumentsList);
                                }
                            });
                        }

                        // 如果是函数，则返回一个包装函数
                        if (typeof value === 'function') {
                            console.log(value.name, 'javvv');
                            if (value.name === 'setInterval' || value.name === 'setTimeout') {
                                return (...args) => {
                                    // 使用原始window对象的上下文调用函数
                                    const id = value.apply(window, args);
                                    timer.push(id)
                                    return id
                                };
                            }
                            if (value.name === 'addEventListener') {
                                return (...args) => {
                                    events.push(args)
                                    // 使用原始window对象的上下文调用函数
                                    return value.apply(window, args);

                                };
                            }
                            return (...args) => {
                                // 使用原始window对象的上下文调用函数
                                return value.apply(window, args);
                            };
                        }
                        return value
                    }
                })
                this.proxy = proxy
            }
        }
        //TODO:报错总结： TypeError: Illegal invocation
        // 1、在你提供的 loadJs 函数中，使用 eval 函数执行脚本并且尝试通过一个立即执行函数（IIFE）将 proxyWindow 作为 window 对象传递
        // 给脚本。如果脚本中使用了例如 console.log、setTimeout、localStorage 等浏览器 API，并且这些 API 被直接赋值给 proxyWindow 对象
        // ，可能会导致 Illegal invocation 错误。
        // 在你的 loadJs 函数中，如果你的脚本尝试调用这些方法或访问像 document 或 localStorage 这类的属性，你需要确保它们被正确地绑定到原始的 window 对象。在将方法和属性复制到 proxyWindow 时，你可能需要使用函数包装器或绑定来保持正确的上下文。
        // 2、 Constructor BigInt64Array requires 'new'（所有构造函数都会有）
        //需要使用 new 关键字来调用，不仅仅是因为它们是函数。当你尝试以普通函数的方式调用它们时，JavaScript 引擎将会抛出错误，因为它们是专门设计用来构造新实例的。
        // 为了解决这个问题，你需要对构造函数进行特殊处理，确保在代理中以构造函数的形式调用它们。


        function loadJs(url, old) {
            const sandBox = new legacySandbox(url)
            const proxyWindow = sandBox.proxy;
            const jsStr = fetch(url).then((res) => {
                return res.text()
            })
                .then((ans) => {
                    eval(`
                if (old) {
                    old.name !== url && old.inactive()
                }
                (function (window, self, globalThis) {
                ${ans}
            }).bind()(proxyWindow, proxyWindow, proxyWindow)
            `)
                })
            return sandBox
        }
        const one = loadJs('./1.js')
        // console.log(one);
        btn.addEventListener('click', () => {
            const one1 = loadJs('./2.js', one)
        })
        // loadJs('./2.js', one)

    </script>
</body>

</html>