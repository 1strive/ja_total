<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>history</title>
</head>

<body>
    <ul>
        <li><a href="/">/</a></li>
        <li><a href="/page1">page1</a></li>
        <li><a href="/page2">page2</a></li>
        <li>
            <div class="render"></div>
        </li>
    </ul>
    <script>
        //hash中#后不会带给服务器
        //但history会直接改变url，每次手动刷新后都会像服务器发起请求，
        // 需要后端配合，对一个路径下的所有子路径做出相应的响应，否则会404

        // const list = document.querySelectorAll('a[href]')
        // for (const ele of list) {
        //     ele.onclick = function (e) {
        //         e.preventDefault()
        //         history.pushState(null, '', ele.getAttribute('href'))//getAttribute() 返回元素上一个指定的属性值。如果指定的属性不存在，则返回  null 或 "" （空字符串）
        //         backBtn.innerHTML = location.pathname
        //     }
        // }

        class HistoryRouter {
            constructor(path) {
                this.routes = {}        // 记录路径标识符对应的cb
                history.replaceState({ path }, '', path) // 进入状态
                //第一个参数保存历史记录
                this.routes[path] && this.routes[path]()
                // window.addEventListener('load', e => {
                //     console.log(e, ' --- esad')
                // })

                //popstate主要起到追踪记录的作用，在浏览器后退前进从而触发history.forward back时触发popstate
                window.addEventListener('popstate', e => {
                    console.log(e.state, 'state');
                    const path = e.state && e.state.path
                    this.routes[path] && this.routes[path]()
                })
            }

            /**
             * 初始化
             */
            static init() {
                window.Router = new HistoryRouter(location.pathname)
            }

            /**
             * 记录path对应cb
             * @param path 路径
             * @param cb 回调
             */
            route(path, cb) {
                this.routes[path] = cb || function () { }
            }

            /**
             * 触发路由对应回调
             * @param path
             */
            go(path) {
                history.pushState({ path }, '', path)
                this.routes[path] && this.routes[path]()
            }
        }
        HistoryRouter.init()
        const ul = document.querySelector('ul')
        const render = document.querySelector('div')
        const changeContent = content => render.innerHTML = content

        Router.route('/', () => changeContent('默认页面'))
        Router.route('/page1', () => changeContent('page1页面'))
        Router.route('/page2', () => changeContent('page2页面'))

        //利用事件委托
        ul.addEventListener('click', e => {
            console.log(e.target.tagName);
            if (e.target.tagName === 'A') {
                e.preventDefault()
                Router.go(e.target.getAttribute('href'))
            }
        })
        // Hash 模式是使用 URL 的 Hash 来模拟一个完整的 URL，因此当 URL 改变的时候页面并不会重载。
        // History 模式则会直接改变 URL，所以在路由跳转的时候会丢失一些地址信息，
        // 在刷新或直接访问路由地址的时候会匹配不到静态资源。因此需要在服务器上配置一些信息，
        // 让服务器增加一个覆盖所有情况的候选资源，比如跳转 index.html 什么的，一般来说是你的 app 依赖的页面，
        // 事实上 vue-router 等库也是这么推介的，还提供了常见的服务器配置。

    </script>
</body>

</html>