<!--
 * @Author: ja
 * @Date: 2022-01-04 16:41:50
 * @LastEditors: ja
 * @LastEditTime: 2022-01-05 20:00:50
-->
<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>私有方法</title>
</head>

<body>
    <script>
        // 私有方法和私有变量，即只能在类内部访问（即通过类内部方法调用）




        //法一 闭包实现

        // var pClass = function () {
        //     var a = '私有变量';
        //     var getA = function () {
        //         console.log(a, '私有方法')
        //     }
        //     var setA = function (val) {
        //         a = val
        //     }
        //     function P() {
        //         this.b = '变量b，外部可访问'
        //     }
        //     P.prototype = {
        //         getB: function () {
        //             console.log(this.b, '--- 获取对象公有属性b ---')
        //         },
        //         setType: function (a, val) {
        //             if (a == 'a') {
        //                 setA(val);
        //             }
        //         },
        //         getType: function (a) {
        //             if (a == 'a') {
        //                 getA();
        //             }
        //         }
        //     }
        //     return P
        // }


        // var PClass1 = pClass(); //开辟了一个函数作用域
        // var PClass2 = pClass(); //重新开辟了一个函数作用域
        // var pclass1 = new PClass1();
        // var pclass2 = new PClass2();
        // pclass1.setType('a', '修改私有属性a的值');
        // pclass1.getType('a');   //打印    修改私有属性a的值  私有方法
        // pclass2.getType('a');   //打印    私有变量 私有方法


        // //法二 ES6之后
        // const Pclass = (function () {
        //     const a = Symbol('a');
        //     const m = Symbol('m');
        //     class Pclass {
        //         [a] = 'a这是私有变量';
        //         b = '变量B-外部可访问';
        //         [m] = function () {
        //             console.log('私有方法');
        //         }
        //         getA() {
        //             console.log(this[a]);
        //         }
        //         getM() {
        //             console.log(this[m]);
        //         }
        //     }
        //     return Pclass
        // }())

        // // 由上述代码我们可以发现 只要不把 a = Symbol('a'); m = Symbol('m') 这两个引用对外暴露，
        // // 外部是无法访问到定义的私有变量a，和私有方法m， 因为他们的真实属性名称是a, m 这两个引用，而且是唯一的。
        // let pc = new Pclass()
        // console.log(pc)   //打印 Pclass {b: "变量B-外部可访问", Symbol(a): "这是私有变量", Symbol(m): ƒ}
        // console.log(pc.a);

        //法三
        // 先来解释下WeakMap类型, 该类型数据是一个键-值（key-val）对的集合，只不过他的键（key）是一个引用，不同于一般的键-值。(weakMap的键值必须是对象)

        var Pclass = (function () {
            const aa = new WeakMap();
            const mt = new WeakMap();
            class Pclass {
                constructor() {
                    this.b = 'b这是公有变量';
                    aa.set(this, '私有变量aa')
                    mt.set(this, function () {
                        console.log('私有方法mt')
                    })
                }
                getA() {
                    console.log(aa.get(this));
                }
                getM() {
                    console.log(mt.get(this));
                }
            }
            return Pclass
        }())
        let pc = new Pclass()
        console.log(pc) // Pclass {b: "b这是公有变量"}


    </script>
</body>

</html>