<!--
 * @Author: ja
 * @Date: 2021-12-29 10:48:08
 * @LastEditors: JA
 * @LastEditTime: 2022-09-04 11:52:06
-->
<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>深拷贝</title>
</head>

<body>
    <script>
        //深拷贝:拷贝还是复制,深:把一个对象中所有的属性或者方法,一个一个的找到.并且在另一个对象中开辟相应的空间,一个一个的存储到另一个对象中
        //浅拷贝更改obj1的属性，obj2的属性也会随之更改，而深拷贝不会
        // const obj1 = {
        //     age: 10,
        //     sex: "男",
        //     car: ["奔驰", "宝马", "特斯拉", "奥拓"],
        //     dog: {
        //         name: "大黄",
        //         age: 5,
        //         color: "黑白色"
        //     }
        // };
        // const obj2 = {};
        //判断拷贝的要进行深拷贝的是数组还是对象，是数组的话进行数组拷贝，对象的话进行对象拷贝
        //本质上是将引用数据类型重新开辟一个地址

        //法一(无法处理循环引用的对象，会造成栈内存溢出)

        function clone(target) {
            if (typeof target === 'object') {
                let cloneTarget = Array.isArray(target) ? [] : {};
                for (const key in target) {
                    cloneTarget[key] = clone(target[key]);
                }
                return cloneTarget;
            } else {
                return target;
            }
        };

        // deepCopy(obj1, obj2)
        // console.log(obj2);
        // console.log(obj1.dog == obj2.dog);

        //法二
        //通过js的内置对象JSON来进行数组对象的深拷贝
        // obj2 = JSON.parse(JSON.stringify(obj1))
        // }
        // 这种写法非常简单，而且可以应对大部分的应用场景，但是它还是有很大缺陷的，比如拷贝其他引用类型、拷贝函数、循环引用等情况。




        //法三：Object.assign()只能浅拷贝
        //针对深拷贝，需要使用其他办法，因为 Object.assign()拷贝的是（可枚举）属性值。
        // 假如源值是一个对象的引用，它仅仅会复制其引用值。
        const obj1 = {
            age: 10,
            sex: "男",
            car: ["奔驰", "宝马", "特斯拉", "奥拓"],
            dog: {
                name: "大黄",
                age: 5,
                color: "黑白色"
            },
            f1: function () {
                console.log(111);
            },
        };
        let obj2 = {}
        Object.assign(obj2, obj1)
        console.log(obj2);
        console.log(obj1);
        obj1.age = 22
        // obj1.car[0] = 'ss'
        // console.log(obj2);
        // console.log(obj1);

        //最终解决方案 
        // map解决循环调用
        //加传参level跟踪递归层数
        const maxClone = (obj) => {
            let deep = 1
            const deepClone = (obj, level = 0, map = new Map()) => {
                deep = Math.max(level, deep)
                if (obj instanceof Object) {
                    let cloneTarget = Array.isArray(obj) ? [] : {}
                    if (!Object.keys(obj).length) {
                        deep = Math.max(level + 1, deep)
                    }
                    if (map.get(obj)) {
                        return target
                    }
                    map.set(obj, cloneTarget)
                    for (const key in obj) {
                        cloneTarget[key] = deepClone(obj[key], level + 1)
                    }
                    return cloneTarget
                } else {
                    return obj
                }
            }
            const ans = deepClone(obj)
            console.log(deep, 'deep');
            return ans
        }

        const ans = maxClone(obj)
        console.log(ans);

   //法四：使用扩展运算符，但也只能复制一层
    </script>
</body>

</html>