<!--
 * @Author: ja
 * @Date: 2021-12-29 11:41:00
 * @LastEditors: ja
 * @LastEditTime: 2021-12-29 17:19:08
-->
<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>test</title>
</head>

<body>
    <script>
        // 解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝，这样就巧妙化解的循环引用的问题。

        // 这个存储空间，需要可以存储 key-value形式的数据，且 key可以是一个引用类型，我们可以选择 Map这种数据结构：

        // 检查map中有无克隆过的对象
        // 有 - 直接返回
        // 没有 - 将当前对象作为key，克隆对象作为value进行存储
        // 继续克隆

        function deepClone(target, map = new Map()) {
            if (target instanceof Object) {
                let cloneTarget = Array.isArray(target) ? [] : {}
                if (map.get(target)) {
                    return target
                }
                map.set(target, cloneTarget)
                for (const key in target) {
                    cloneTarget[key] = deepClone(target[key], map)
                }
                return cloneTarget
            } else return target
        }

        const target = {
            field1: 1,
            field2: undefined,
            field3: {
                child: 'child'
            },
            field4: [2, 4, 8]
        };
        target.target = target;


        let obj = {}

        const t1 = deepClone(target)
        console.log(t1);




    </script>
</body>

</html>