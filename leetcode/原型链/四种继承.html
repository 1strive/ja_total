<!--
 * @Author: JA
 * @Date: 2022-09-15 18:39:34
 * @LastEditTime: 2022-09-15 23:30:07
 * @LastEditors: JA
-->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>四种继承</title>
</head>

<body>
    <script>
        // 1、单独使用原型链进行继承   
        // 问题：1、共享特性 2、无法在不影响所以对象实例的情况下把参数传进父类的构造函数
        // function Supertype() {
        //     this.property = '焦傲'
        //     this.arr = [1, 2, 3]
        // }

        // Supertype.prototype.getSuperValue = function () {
        //     return this.property
        // }

        // function Subtype() {
        //     this.subproperty = false
        // }

        // Subtype.prototype = new Supertype()
        // console.log(Subtype.prototype);
        // const ans = new Subtype()
        // const a1 = new Subtype()
        // ans.property = 'aa'
        // console.log(ans.property);//基本数据类型因为存在遮蔽不会受到共享特性的影响
        // console.log(a1.property);
        // ans.arr.push(44)
        // console.log(ans.arr);
        // console.log(a1.arr);//引用数据类型会因共享特性受到影响


        //单独使用盗用构造函数（//经典继承）（使用call apply实现构造函数属性的继承）
        // 缺点：即构造函数的缺点 函数不能重用  且子类不能访问父类的方法
        // function Supertype(name) {
        //     this.name = name
        //     this.property = '焦傲'
        //     this.arr = [1, 2, 3]
        // }

        // function Subtype(name) {
        //     Supertype.call(this, name)
        //     this.subproperty = false
        // }
        // const sub = new Subtype('嘻嘻哈哈')
        // console.log(sub);

        //常用继承模型

        //组合继承  原型链 + 盗用构造函数
        // 缺点：存在效率问题，即父类构造函数始终会被调用两次：一次在创建子类原型时，一次在子类构造函数中
        // function Supertype(name) {
        //     this.name = name
        //     this.property = '焦傲'
        //     this.arr = [1, 2, 3]
        // }
        // Supertype.prototype.say = function () {
        //     console.log(this.name);
        // }

        // function Subtype(name) {
        //     //继承属性
        //     Supertype.call(this, name)
        //     this.subproperty = false
        // }
        // //继承方法
        // //重写原型会导致constructor缺失
        // Subtype.prototype = new Supertype()
        // // 可以补齐缺失的constructor
        // // Object.defineProperty(Subtype.prototype, 'constructor', {
        // //     value: Subtype,
        // //     enumerable: false,
        // //     writable: false,
        // //     configurable: false
        // // })
        // Subtype.prototype.subSay = function () {
        //     console.log(this.subproperty);
        // }
        // const sub = new Subtype('嘻嘻哈哈')
        // console.log(sub);
        // sub.say()
        // sub.subSay()

        //原型式继承
        // 缺点与原型模式一样  引用值共享问题
        // function obj(o) {
        //     function F() { }
        //     F.prototype = o
        //     return new F
        // }//该函数等价于Object.create()只有一个参数时
        // const a = {
        //     test: '123',
        //     add() {
        //         return this.test
        //     }
        // }
        // const ans = Object.create(a)//a变为ans的隐式原型对象
        // console.log(Object.getPrototypeOf(ans) === a);
        // console.log(ans.add());//123
        // console.log(ans instanceof a);//报错 instanceof后必须是构造函数

        //寄生式继承
        // 缺点：函数难以重用，与构造函数类似
        // function createAnother(original) {
        //     let clone = Object.create(original)//创建对象   此处create不是必须的，任何返回新对象的函数都可以在此使用
        //     clone.sayHi = function () {//增强对象
        //         console.log('哈哈哈');
        //     }
        //     return clone
        // }
        //寄生式组合继承（ES6后由类实现）
        //只调用一次父类 效率更高
        function Supertype(name) {
            this.name = name
            this.property = '焦傲'
            this.arr = [1, 2, 3]
        }
        Supertype.prototype.say = function () {
            console.log(this.name);
        }

        function Subtype(name) {
            Supertype.call(this, name)//继承属性
            this.subproperty = false
        }
        function inheritPrototype(Subtype, Supertype) {
            let prototype = Object.create(Supertype.prototype)  //继承方法  创建对象
            prototype.constructor = Subtype //增强对象
            Subtype.prototype = prototype
        }

        inheritPrototype(Subtype, Supertype)
        const sub = new Subtype('ka')
    </script>
</body>

</html>