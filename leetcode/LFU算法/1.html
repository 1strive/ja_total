<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LFU</title>
</head>

<body>
    <script>

        class LFUCache {

            constructor(capacity) {
                // 缓存空间大小
                this.size = capacity;
                // 缓存存储
                this.values = new Map(); // key:value
                this.times = new Map(); // key：次数
                // 找到当前次数最小的key
                // useMap更新的逻辑，其实vue的响应式依赖管理很像
                this.useMap = new Map(); // 次数：key，set(key)
                this.min = 0; // 最小次数是多少
            }

            get(key) {
                if (this.values.has(key)) {
                    // 更新计数
                    this.updateCount(key);
                    return this.values.get(key);
                }
                return -1;
            }

            put(key, value) {
                // 缓存空间为 0，不操作
                if (this.size === 0) return;
                if (this.values.has(key)) {
                    // key值存在，不需要淘汰
                    this.values.set(key, value);
                    this.updateCount(key);
                } else {
                    // key值不存在，判断是否超过缓存 size
                    if (this.size === this.values.size) {
                        // 满了需要淘汰掉 次数最少的、最长时间未访问的
                        let minSet = this.useMap.get(this.min);
                        let minKey = minSet.keys().next().value;//取出set中第一个
                        minSet.delete(minKey);
                        this.values.delete(minKey);
                        this.times.delete(minKey);
                    }
                    // 加入缓存
                    this.values.set(key, value);
                    // 这个数据出现了 1 次
                    //首次需初始化set
                    let useSet = this.useMap.get(1) || (new Set());
                    useSet.add(key);
                    this.useMap.set(1, useSet);
                    this.times.set(key, 1);
                    this.min = 1;
                }
            }

            updateCount(key) {
                let time = this.times.get(key);
                let useSet = this.useMap.get(time);
                if (this.min === time && useSet.size === 1) {
                    //当前次数是最小值 并且 这个次数set集合只有一个 key
                    this.min += 1;
                }
                time += 1;
                useSet.delete(key);
                //添加至次数+1的set中
                useSet = this.useMap.get(time) || new Set();
                useSet.add(key);
                this.useMap.set(time, useSet);
                this.times.set(key, time);
            }
        }
        let lfu = new LFUCache(2);
        lfu.put(1, 1);   // cache=[1,_], cnt(1)=1
        lfu.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1
        console.log(lfu.get(1));      // 返回 1
        // cache=[1,2], cnt(2)=1, cnt(1)=2
        lfu.put(3, 3);   // 去除键 2 ，因为 cnt(2)=1 ，使用计数最小
        // cache=[3,1], cnt(3)=1, cnt(1)=2
        console.log(lfu.get(2))      // 返回 -1（未找到）
        console.log(lfu.get(3))      // 返回 3
        // cache=[3,1], cnt(3)=2, cnt(1)=2
        lfu.put(4, 4);   // 去除键 1 ，1 和 3 的 cnt 相同，但 1 最久未使用
        // cache=[4,3], cnt(4)=1, cnt(3)=2
        console.log(lfu.get(1))      // 返回 -1（未找到）
        console.log(lfu.get(3))      // 返回 3
        // cache=[3,4], cnt(4)=1, cnt(3)=3
        console.log(lfu.get(4))      // 返回 4
        // cache=[3,4], cnt(4)=2, cnt(3)=3
        const set = new Set([1, 2, 3])
        const p = set.keys()
    </script>
</body>

</html>