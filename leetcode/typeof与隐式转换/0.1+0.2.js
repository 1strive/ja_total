console.log(0.1 + 0.2);//0.30000000000000004
// 前面提到，计算机中存储小数是先转换成二进制进行存储的，我们来看一下0.1和0.2转换成二进制的结果：

// (0.1)10 => (00011001100110011001(1001)...)2

// (0.2)10 => (00110011001100110011(0011)...)2

// 可以发现，0.1和0.2转成二进制之后都是一个无限循环的数，前面提到尾数位只能存储最多53位有效数字，这时候就必须来进行四舍五入了，而这个取舍的规则就是在IEEE 754中定义的，0.1最终能被存储的有效数字是

// 0001(1001)(1001)(1001)(1001)(1001)(1001)(1001)(1001)(1001)(1001)(1001)(1001)101
// +
// (0011)(0011)(0011)(0011)(0011)(0011)(0011)(0011)(0011)(0011)(0011)(0011)(0011)01
// =
// 0100(1100)(1100)(1100)(1100)(1100)(1100)(1100)(1100)(1100)(1100)(1100)(1100)111
// 最终的这个二进制数转成十进制就是0.30000000000000004（不信的话可以找一个在线进制转换工具试一下。
//计算机底层存储数字 就是二进制的科学计数法  1.M * 2^E(此处是E次方)

// 对于学过其他语言的程序员来说，JS中缺少显式整数类型常常令人困惑。许多编程语言支持多种数字类型，如浮点型、双精度型、整数型和双精度型，但JS却不是这样。在JS中，按照IEEE 754-2008标准的定义，所有数字都以双精度64位浮点格式表示。
// 在此标准下，无法精确表示的非常大的整数将自动四舍五入。确切地说，JS 中的Number类型只能安全地表示-9007199254740991 (-(2^53-1)) 和9007199254740991(2^53-1)之间的整数，任何超出此范围的整数值都可能失去精度。
// 要创建BigInt，只需在整数的末尾追加n即可